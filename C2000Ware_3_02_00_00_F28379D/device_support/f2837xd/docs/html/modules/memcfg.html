

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MEMCFG Module &mdash; F2837xd API Guide</title>
  

  
  
    <link rel="shortcut icon" href="../_static/tiicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="F2837xd API Guide" href="../index.html"/>
        <link rel="up" title="Modules" href="index.html"/>
        <link rel="next" title="SCI Module" href="sci.html"/>
        <link rel="prev" title="MCBSP Module" href="mcbsp.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="http://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> F2837xd API Guide
          

          
          </a>

          
            
            
              <div class="version">
                v3.02.00.00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model.html">Programming Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Driver Library Usage</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="adc.html">ADC Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="asysctl.html">ASysCtl Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">CAN Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cla.html">CLA Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="clb.html">CLB Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmpss.html">CMPSS Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cputimer.html">CPU Timer Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dac.html">DAC Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dcsm.html">DCSM Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma.html">DMA Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ecap.html">ECAP Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="emif.html">EMIF Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="epwm.html">EPWM Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hrpwm.html">HRPWM Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="eqep.html">EQEP Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="flash.html">FLASH Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">GPIO Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I2C Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="interrupt.html">Interrupt Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="mcbsp.html">MCBSP Module</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MEMCFG Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sci.html">SCI Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sdfm.html">SDFM Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">SPI Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysctl.html">SYSCTL Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb.html">USB Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="upp.html">UPP Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="version.html">Version</a></li>
<li class="toctree-l2"><a class="reference internal" href="xbar.html">XBAR Module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">F2837xd API Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Modules</a> &raquo;</li>
        
      <li>MEMCFG Module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memcfg-module">
<span id="memcfg"></span><h1>MEMCFG Module<a class="headerlink" href="#memcfg-module" title="Permalink to this headline">¶</a></h1>
<p>The MemCfg module provides an API to configure the device’s Memory Control
Module. The functions that are provided fall into three main categories: RAM
section configuration, access violation status and interrupts, and memory error
status an interrupts. The RAM section configuration functions can initialize
RAM, configure access protection settings, and configure section ownership. The
access violation and memory error categories contain functions that can return
violation and error status and address information as well as configure
interrupts that can be generated as a result of these issues.</p>
<dl class="group">
<dt>
<span class="target" id="group__memcfg__api"></span><em>group</em> <code class="sig-name descname">memcfg_api</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_TYPE_MASK">
<span class="target" id="group__memcfg__api_1g88e6d2b8b0da9dcb73bfa78d52a5293e"></span><code class="sig-name descname">MEMCFG_SECT_TYPE_MASK</code><a class="headerlink" href="#c.MEMCFG_SECT_TYPE_MASK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_TYPE_D">
<span class="target" id="group__memcfg__api_1gc8c3d55369229677b29a842657c984ae"></span><code class="sig-name descname">MEMCFG_SECT_TYPE_D</code><a class="headerlink" href="#c.MEMCFG_SECT_TYPE_D" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_TYPE_LS">
<span class="target" id="group__memcfg__api_1g52b2a8920d5bf6c5aee4f56efd607d37"></span><code class="sig-name descname">MEMCFG_SECT_TYPE_LS</code><a class="headerlink" href="#c.MEMCFG_SECT_TYPE_LS" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_TYPE_GS">
<span class="target" id="group__memcfg__api_1ga3bc98c6347c41fbbdc019e996d91509"></span><code class="sig-name descname">MEMCFG_SECT_TYPE_GS</code><a class="headerlink" href="#c.MEMCFG_SECT_TYPE_GS" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_TYPE_MSG">
<span class="target" id="group__memcfg__api_1g20aacefe571b44694720bf1bed58b797"></span><code class="sig-name descname">MEMCFG_SECT_TYPE_MSG</code><a class="headerlink" href="#c.MEMCFG_SECT_TYPE_MSG" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_NUM_MASK">
<span class="target" id="group__memcfg__api_1g92d41c43e405900ad52a81b3eacaa9ab"></span><code class="sig-name descname">MEMCFG_SECT_NUM_MASK</code><a class="headerlink" href="#c.MEMCFG_SECT_NUM_MASK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_XACCPROTX_M">
<span class="target" id="group__memcfg__api_1gca30a235ea1651cace794a23201b86db"></span><code class="sig-name descname">MEMCFG_XACCPROTX_M</code><a class="headerlink" href="#c.MEMCFG_XACCPROTX_M" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_XTEST_M">
<span class="target" id="group__memcfg__api_1gc9f3d33d2dfc83709be6141cb7218da5"></span><code class="sig-name descname">MEMCFG_XTEST_M</code><a class="headerlink" href="#c.MEMCFG_XTEST_M" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_MASK">
<span class="target" id="group__memcfg__api_1g4e46c40be9c9471a804689c4092db150"></span><code class="sig-name descname">MEMCFG_NMVIOL_MASK</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_MASK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_MVIOL_MASK">
<span class="target" id="group__memcfg__api_1g06a1406c159db7838d028b7d1eaf0b15"></span><code class="sig-name descname">MEMCFG_MVIOL_MASK</code><a class="headerlink" href="#c.MEMCFG_MVIOL_MASK" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_MVIOL_SHIFT">
<span class="target" id="group__memcfg__api_1gac1b1cbf777a96bdf79a866b9ccc8663"></span><code class="sig-name descname">MEMCFG_MVIOL_SHIFT</code><a class="headerlink" href="#c.MEMCFG_MVIOL_SHIFT" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_M0">
<span class="target" id="group__memcfg__api_1gac8fb238fdca87bb366292e61a209e48"></span><code class="sig-name descname">MEMCFG_SECT_M0</code><a class="headerlink" href="#c.MEMCFG_SECT_M0" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>M0 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_M1">
<span class="target" id="group__memcfg__api_1gceb9dde7b1b0b89fac6aa8483ce2a790"></span><code class="sig-name descname">MEMCFG_SECT_M1</code><a class="headerlink" href="#c.MEMCFG_SECT_M1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>M1 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_D0">
<span class="target" id="group__memcfg__api_1g299dc26130187188f6cb89713c9d4b82"></span><code class="sig-name descname">MEMCFG_SECT_D0</code><a class="headerlink" href="#c.MEMCFG_SECT_D0" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>D0 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_D1">
<span class="target" id="group__memcfg__api_1g7762fb4023d146efda7e349c1293d521"></span><code class="sig-name descname">MEMCFG_SECT_D1</code><a class="headerlink" href="#c.MEMCFG_SECT_D1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>D1 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_DX_ALL">
<span class="target" id="group__memcfg__api_1gd0389cb27187041909bd07da8e608952"></span><code class="sig-name descname">MEMCFG_SECT_DX_ALL</code><a class="headerlink" href="#c.MEMCFG_SECT_DX_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>All M and D RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS0">
<span class="target" id="group__memcfg__api_1gc98dca0c899394f40c23a606d7ae37a0"></span><code class="sig-name descname">MEMCFG_SECT_LS0</code><a class="headerlink" href="#c.MEMCFG_SECT_LS0" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS0 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS1">
<span class="target" id="group__memcfg__api_1g41e7482af97b7e6656c2e90f26d8f588"></span><code class="sig-name descname">MEMCFG_SECT_LS1</code><a class="headerlink" href="#c.MEMCFG_SECT_LS1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS1 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS2">
<span class="target" id="group__memcfg__api_1g204c2e400cab5c53774f5601456cfbc8"></span><code class="sig-name descname">MEMCFG_SECT_LS2</code><a class="headerlink" href="#c.MEMCFG_SECT_LS2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS2 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS3">
<span class="target" id="group__memcfg__api_1g177b15fc204d57402eb786a9ce89fe22"></span><code class="sig-name descname">MEMCFG_SECT_LS3</code><a class="headerlink" href="#c.MEMCFG_SECT_LS3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS3 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS4">
<span class="target" id="group__memcfg__api_1g518e7907eb882d6ebe043f78097f6670"></span><code class="sig-name descname">MEMCFG_SECT_LS4</code><a class="headerlink" href="#c.MEMCFG_SECT_LS4" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS4 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LS5">
<span class="target" id="group__memcfg__api_1g6892c77d0329df4dec1ee8068a607402"></span><code class="sig-name descname">MEMCFG_SECT_LS5</code><a class="headerlink" href="#c.MEMCFG_SECT_LS5" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>LS5 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_LSX_ALL">
<span class="target" id="group__memcfg__api_1g2381913e7e412f01aed422df43521c67"></span><code class="sig-name descname">MEMCFG_SECT_LSX_ALL</code><a class="headerlink" href="#c.MEMCFG_SECT_LSX_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>All LS RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS0">
<span class="target" id="group__memcfg__api_1gafe60d83da39f5b0740a035cb5937a25"></span><code class="sig-name descname">MEMCFG_SECT_GS0</code><a class="headerlink" href="#c.MEMCFG_SECT_GS0" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS0 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS1">
<span class="target" id="group__memcfg__api_1g87ee3d7ec87e133f4ef21ef9f7bd2a19"></span><code class="sig-name descname">MEMCFG_SECT_GS1</code><a class="headerlink" href="#c.MEMCFG_SECT_GS1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS1 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS2">
<span class="target" id="group__memcfg__api_1g8309a138bcd9d6dfa678e9f92f198271"></span><code class="sig-name descname">MEMCFG_SECT_GS2</code><a class="headerlink" href="#c.MEMCFG_SECT_GS2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS2 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS3">
<span class="target" id="group__memcfg__api_1gf7982bb59b0ee59f6615d85af9be7854"></span><code class="sig-name descname">MEMCFG_SECT_GS3</code><a class="headerlink" href="#c.MEMCFG_SECT_GS3" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS3 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS4">
<span class="target" id="group__memcfg__api_1gd716575183af608bad53a43e63fe23d2"></span><code class="sig-name descname">MEMCFG_SECT_GS4</code><a class="headerlink" href="#c.MEMCFG_SECT_GS4" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS4 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS5">
<span class="target" id="group__memcfg__api_1gf8cc27133b01315488603b0094f1147c"></span><code class="sig-name descname">MEMCFG_SECT_GS5</code><a class="headerlink" href="#c.MEMCFG_SECT_GS5" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS5 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS6">
<span class="target" id="group__memcfg__api_1gf920d8dfbcd32292f474103da34e95c4"></span><code class="sig-name descname">MEMCFG_SECT_GS6</code><a class="headerlink" href="#c.MEMCFG_SECT_GS6" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS6 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS7">
<span class="target" id="group__memcfg__api_1g0fb95cf7bb7b16b68e7a3163c6253f5e"></span><code class="sig-name descname">MEMCFG_SECT_GS7</code><a class="headerlink" href="#c.MEMCFG_SECT_GS7" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS7 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS8">
<span class="target" id="group__memcfg__api_1gfd7589c266774b36f3ead6e3f7a34e5b"></span><code class="sig-name descname">MEMCFG_SECT_GS8</code><a class="headerlink" href="#c.MEMCFG_SECT_GS8" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS8 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS9">
<span class="target" id="group__memcfg__api_1gb97552c23814328832b84553f6e1edea"></span><code class="sig-name descname">MEMCFG_SECT_GS9</code><a class="headerlink" href="#c.MEMCFG_SECT_GS9" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS9 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS10">
<span class="target" id="group__memcfg__api_1g56dff7005983deb0c2b450e631edd2a1"></span><code class="sig-name descname">MEMCFG_SECT_GS10</code><a class="headerlink" href="#c.MEMCFG_SECT_GS10" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS10 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS11">
<span class="target" id="group__memcfg__api_1g99d2224c98dfbabdb311ae39a6e149f1"></span><code class="sig-name descname">MEMCFG_SECT_GS11</code><a class="headerlink" href="#c.MEMCFG_SECT_GS11" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS11 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS12">
<span class="target" id="group__memcfg__api_1g0705f7e7c4331508182696f2ca02540e"></span><code class="sig-name descname">MEMCFG_SECT_GS12</code><a class="headerlink" href="#c.MEMCFG_SECT_GS12" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS12 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS13">
<span class="target" id="group__memcfg__api_1ga11b06e4d630ef83fefdf3702dbaec88"></span><code class="sig-name descname">MEMCFG_SECT_GS13</code><a class="headerlink" href="#c.MEMCFG_SECT_GS13" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS13 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS14">
<span class="target" id="group__memcfg__api_1g28288cd3ee281e4e347b379c14053968"></span><code class="sig-name descname">MEMCFG_SECT_GS14</code><a class="headerlink" href="#c.MEMCFG_SECT_GS14" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS14 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GS15">
<span class="target" id="group__memcfg__api_1g4da7b49380b173b2310e739bfcbd541b"></span><code class="sig-name descname">MEMCFG_SECT_GS15</code><a class="headerlink" href="#c.MEMCFG_SECT_GS15" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>GS15 RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_GSX_ALL">
<span class="target" id="group__memcfg__api_1gf71f6ce025c17a5ef1da4588d82d3e48"></span><code class="sig-name descname">MEMCFG_SECT_GSX_ALL</code><a class="headerlink" href="#c.MEMCFG_SECT_GSX_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>All GS RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_MSGCPUTOCPU">
<span class="target" id="group__memcfg__api_1ga506c2922bdc4a9555fefe3fd88f77f8"></span><code class="sig-name descname">MEMCFG_SECT_MSGCPUTOCPU</code><a class="headerlink" href="#c.MEMCFG_SECT_MSGCPUTOCPU" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU-to-CPU message RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_MSGCPUTOCLA1">
<span class="target" id="group__memcfg__api_1gaa2779cae1ed61cc069163450cd13ed3"></span><code class="sig-name descname">MEMCFG_SECT_MSGCPUTOCLA1</code><a class="headerlink" href="#c.MEMCFG_SECT_MSGCPUTOCLA1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU-to-CLA1 message RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_MSGCLA1TOCPU">
<span class="target" id="group__memcfg__api_1gd9f8e84d707dc3eedc8cc6394ef045d4"></span><code class="sig-name descname">MEMCFG_SECT_MSGCLA1TOCPU</code><a class="headerlink" href="#c.MEMCFG_SECT_MSGCLA1TOCPU" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CLA1-to-CPU message RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_MSGX_ALL">
<span class="target" id="group__memcfg__api_1g42aa8a64747a4449ab86bcf27d947782"></span><code class="sig-name descname">MEMCFG_SECT_MSGX_ALL</code><a class="headerlink" href="#c.MEMCFG_SECT_MSGX_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>All message RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_SECT_ALL">
<span class="target" id="group__memcfg__api_1g92704001833b62ead00f6923e0d0269e"></span><code class="sig-name descname">MEMCFG_SECT_ALL</code><a class="headerlink" href="#c.MEMCFG_SECT_ALL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>All configurable RAM. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_ALLOWCPUFETCH">
<span class="target" id="group__memcfg__api_1g380b5029567abd98d8dbf6b59ed52b38"></span><code class="sig-name descname">MEMCFG_PROT_ALLOWCPUFETCH</code><a class="headerlink" href="#c.MEMCFG_PROT_ALLOWCPUFETCH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU fetch allowed. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_BLOCKCPUFETCH">
<span class="target" id="group__memcfg__api_1g15f10b8e60ff8224ef392b0e52b7c0cd"></span><code class="sig-name descname">MEMCFG_PROT_BLOCKCPUFETCH</code><a class="headerlink" href="#c.MEMCFG_PROT_BLOCKCPUFETCH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU fetch blocked. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_ALLOWCPUWRITE">
<span class="target" id="group__memcfg__api_1ga82921deb17f0ac84fb18f36275934b2"></span><code class="sig-name descname">MEMCFG_PROT_ALLOWCPUWRITE</code><a class="headerlink" href="#c.MEMCFG_PROT_ALLOWCPUWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU write allowed. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_BLOCKCPUWRITE">
<span class="target" id="group__memcfg__api_1gac0ac089a09db8c9e1c000fc42b64945"></span><code class="sig-name descname">MEMCFG_PROT_BLOCKCPUWRITE</code><a class="headerlink" href="#c.MEMCFG_PROT_BLOCKCPUWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU write blocked. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_ALLOWDMAWRITE">
<span class="target" id="group__memcfg__api_1g26d3e2d638a38a0d4b090e18d47f7e70"></span><code class="sig-name descname">MEMCFG_PROT_ALLOWDMAWRITE</code><a class="headerlink" href="#c.MEMCFG_PROT_ALLOWDMAWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DMA write allowed (GSxRAM). </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_PROT_BLOCKDMAWRITE">
<span class="target" id="group__memcfg__api_1g675872cc78bad6b9b2165ca92342b027"></span><code class="sig-name descname">MEMCFG_PROT_BLOCKDMAWRITE</code><a class="headerlink" href="#c.MEMCFG_PROT_BLOCKDMAWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>DMA write blocked (GSxRAM). </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CPUREAD">
<span class="target" id="group__memcfg__api_1g071beb96a10a459fa56a70380f357ac6"></span><code class="sig-name descname">MEMCFG_NMVIOL_CPUREAD</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CPUREAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CPU read access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CPUWRITE">
<span class="target" id="group__memcfg__api_1g19b4099cb91aeb739750efaa02dde622"></span><code class="sig-name descname">MEMCFG_NMVIOL_CPUWRITE</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CPUWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CPU write access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CPUFETCH">
<span class="target" id="group__memcfg__api_1ga555ee7f73fa3b743a9b579fa1669b27"></span><code class="sig-name descname">MEMCFG_NMVIOL_CPUFETCH</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CPUFETCH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CPU fetch access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_DMAWRITE">
<span class="target" id="group__memcfg__api_1g10a6e9e3ff33adb83439f3834df8150c"></span><code class="sig-name descname">MEMCFG_NMVIOL_DMAWRITE</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_DMAWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master DMA write access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CLA1READ">
<span class="target" id="group__memcfg__api_1g287ebc17c38963120c78aefb476c6874"></span><code class="sig-name descname">MEMCFG_NMVIOL_CLA1READ</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CLA1READ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CLA1 read access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CLA1WRITE">
<span class="target" id="group__memcfg__api_1g0bc274c346620cd1be6407e3613edf5b"></span><code class="sig-name descname">MEMCFG_NMVIOL_CLA1WRITE</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CLA1WRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CLA1 write access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_NMVIOL_CLA1FETCH">
<span class="target" id="group__memcfg__api_1g838aa80cf95728fd7d7f70da32a66d5c"></span><code class="sig-name descname">MEMCFG_NMVIOL_CLA1FETCH</code><a class="headerlink" href="#c.MEMCFG_NMVIOL_CLA1FETCH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Non-master CLA1 fetch access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_MVIOL_CPUFETCH">
<span class="target" id="group__memcfg__api_1g0472c4fe236f8ea8c116985f399eb1d7"></span><code class="sig-name descname">MEMCFG_MVIOL_CPUFETCH</code><a class="headerlink" href="#c.MEMCFG_MVIOL_CPUFETCH" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Master CPU fetch access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_MVIOL_CPUWRITE">
<span class="target" id="group__memcfg__api_1g9b076f6defdd5429048b6c067b2e3bb2"></span><code class="sig-name descname">MEMCFG_MVIOL_CPUWRITE</code><a class="headerlink" href="#c.MEMCFG_MVIOL_CPUWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Master CPU write access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_MVIOL_DMAWRITE">
<span class="target" id="group__memcfg__api_1g90a67464061a27d24446289091d12108"></span><code class="sig-name descname">MEMCFG_MVIOL_DMAWRITE</code><a class="headerlink" href="#c.MEMCFG_MVIOL_DMAWRITE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Master DMA write access. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_CERR_CPUREAD">
<span class="target" id="group__memcfg__api_1g1c18f77b00ed6f1a4efdb9d62d83419c"></span><code class="sig-name descname">MEMCFG_CERR_CPUREAD</code><a class="headerlink" href="#c.MEMCFG_CERR_CPUREAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Correctable CPU read error. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_CERR_DMAREAD">
<span class="target" id="group__memcfg__api_1g8500a8aaa6396ddeb69caeb887eb2747"></span><code class="sig-name descname">MEMCFG_CERR_DMAREAD</code><a class="headerlink" href="#c.MEMCFG_CERR_DMAREAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Correctable DMA read error. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_CERR_CLA1READ">
<span class="target" id="group__memcfg__api_1g63a54a6efecba97fefe5d22aec84f0c4"></span><code class="sig-name descname">MEMCFG_CERR_CLA1READ</code><a class="headerlink" href="#c.MEMCFG_CERR_CLA1READ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Correctable CLA1 read error. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_UCERR_CPUREAD">
<span class="target" id="group__memcfg__api_1g662ee6c27a51a9a9a781335bc75d2beb"></span><code class="sig-name descname">MEMCFG_UCERR_CPUREAD</code><a class="headerlink" href="#c.MEMCFG_UCERR_CPUREAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uncorrectable CPU read error. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_UCERR_DMAREAD">
<span class="target" id="group__memcfg__api_1gc4f8e360edf16e99f6ebe5e439977ee4"></span><code class="sig-name descname">MEMCFG_UCERR_DMAREAD</code><a class="headerlink" href="#c.MEMCFG_UCERR_DMAREAD" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uncorrectable DMA read error. </p>
</dd></dl>

<dl class="cpp macro">
<dt id="c.MEMCFG_UCERR_CLA1READ">
<span class="target" id="group__memcfg__api_1gdda6ac66f90301a3456ffe5355a9880b"></span><code class="sig-name descname">MEMCFG_UCERR_CLA1READ</code><a class="headerlink" href="#c.MEMCFG_UCERR_CLA1READ" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Uncorrectable CLA1 read error. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="cpp enum">
<dt id="_CPPv420MemCfg_CLAMemoryType">
<span id="_CPPv320MemCfg_CLAMemoryType"></span><span id="_CPPv220MemCfg_CLAMemoryType"></span><span class="target" id="group__memcfg__api_1g03ca9d27745c093e8c2d0007efd17786"></span><em class="property">enum </em><code class="sig-name descname">MemCfg_CLAMemoryType</code><a class="headerlink" href="#_CPPv420MemCfg_CLAMemoryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Values that can be passed to <a class="reference internal" href="#group__memcfg__api_1g3196086df04b57ef67f5f6c425287274"><span class="std std-ref">MemCfg_setCLAMemType()</span></a> as the <em>claMemType</em> parameter. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv419MEMCFG_CLA_MEM_DATA">
<span id="_CPPv319MEMCFG_CLA_MEM_DATA"></span><span id="_CPPv219MEMCFG_CLA_MEM_DATA"></span><span class="target" id="group__memcfg__api_1gg03ca9d27745c093e8c2d0007efd17786ccce71d204ef1fc5124165e01cf45d59"></span><code class="sig-name descname">MEMCFG_CLA_MEM_DATA</code><a class="headerlink" href="#_CPPv419MEMCFG_CLA_MEM_DATA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Section is CLA data memory. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv422MEMCFG_CLA_MEM_PROGRAM">
<span id="_CPPv322MEMCFG_CLA_MEM_PROGRAM"></span><span id="_CPPv222MEMCFG_CLA_MEM_PROGRAM"></span><span class="target" id="group__memcfg__api_1gg03ca9d27745c093e8c2d0007efd17786e4c8eb8c1000694eb18ba02304bad8a3"></span><code class="sig-name descname">MEMCFG_CLA_MEM_PROGRAM</code><a class="headerlink" href="#_CPPv422MEMCFG_CLA_MEM_PROGRAM" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Section is CLA program memory. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt id="_CPPv421MemCfg_LSRAMMasterSel">
<span id="_CPPv321MemCfg_LSRAMMasterSel"></span><span id="_CPPv221MemCfg_LSRAMMasterSel"></span><span class="target" id="group__memcfg__api_1g5b6cb8959b12519910cfd7920e095a4e"></span><em class="property">enum </em><code class="sig-name descname">MemCfg_LSRAMMasterSel</code><a class="headerlink" href="#_CPPv421MemCfg_LSRAMMasterSel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Values that can be passed to <a class="reference internal" href="#group__memcfg__api_1gc0296e36c63153eb8b24d19fc7b55a27"><span class="std std-ref">MemCfg_setLSRAMMasterSel()</span></a> as the <em>masterSel</em> parameter. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv427MEMCFG_LSRAMMASTER_CPU_ONLY">
<span id="_CPPv327MEMCFG_LSRAMMASTER_CPU_ONLY"></span><span id="_CPPv227MEMCFG_LSRAMMASTER_CPU_ONLY"></span><span class="target" id="group__memcfg__api_1gg5b6cb8959b12519910cfd7920e095a4e9f7a389386bcd6e2ebc04d14075242ef"></span><code class="sig-name descname">MEMCFG_LSRAMMASTER_CPU_ONLY</code><a class="headerlink" href="#_CPPv427MEMCFG_LSRAMMASTER_CPU_ONLY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU is the master of the section. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv427MEMCFG_LSRAMMASTER_CPU_CLA1">
<span id="_CPPv327MEMCFG_LSRAMMASTER_CPU_CLA1"></span><span id="_CPPv227MEMCFG_LSRAMMASTER_CPU_CLA1"></span><span class="target" id="group__memcfg__api_1gg5b6cb8959b12519910cfd7920e095a4e025bb7c6d95e44285c8e69e3e9220c6e"></span><code class="sig-name descname">MEMCFG_LSRAMMASTER_CPU_CLA1</code><a class="headerlink" href="#_CPPv427MEMCFG_LSRAMMASTER_CPU_CLA1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU and CLA1 share this section. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt id="_CPPv421MemCfg_GSRAMMasterSel">
<span id="_CPPv321MemCfg_GSRAMMasterSel"></span><span id="_CPPv221MemCfg_GSRAMMasterSel"></span><span class="target" id="group__memcfg__api_1g0b9ca2eece3eb11254ffd5be6e877d56"></span><em class="property">enum </em><code class="sig-name descname">MemCfg_GSRAMMasterSel</code><a class="headerlink" href="#_CPPv421MemCfg_GSRAMMasterSel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Values that can be passed to <a class="reference internal" href="#group__memcfg__api_1gbf7d1f375842e688acc5fabf7e2c655b"><span class="std std-ref">MemCfg_setGSRAMMasterSel()</span></a> as the <em>masterSel</em> parameter. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv423MEMCFG_GSRAMMASTER_CPU1">
<span id="_CPPv323MEMCFG_GSRAMMASTER_CPU1"></span><span id="_CPPv223MEMCFG_GSRAMMASTER_CPU1"></span><span class="target" id="group__memcfg__api_1gg0b9ca2eece3eb11254ffd5be6e877d56adca6125113460a382bf6c4e5ff70ece"></span><code class="sig-name descname">MEMCFG_GSRAMMASTER_CPU1</code><a class="headerlink" href="#_CPPv423MEMCFG_GSRAMMASTER_CPU1" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU1 is master of the section. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv423MEMCFG_GSRAMMASTER_CPU2">
<span id="_CPPv323MEMCFG_GSRAMMASTER_CPU2"></span><span id="_CPPv223MEMCFG_GSRAMMASTER_CPU2"></span><span class="target" id="group__memcfg__api_1gg0b9ca2eece3eb11254ffd5be6e877d566c68df87e967fb6d7641fcb6b6f98330"></span><code class="sig-name descname">MEMCFG_GSRAMMASTER_CPU2</code><a class="headerlink" href="#_CPPv423MEMCFG_GSRAMMASTER_CPU2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>CPU2 is master of the section. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt id="_CPPv415MemCfg_TestMode">
<span id="_CPPv315MemCfg_TestMode"></span><span id="_CPPv215MemCfg_TestMode"></span><span class="target" id="group__memcfg__api_1gcc0bcf96536c11210db605f4f1268eef"></span><em class="property">enum </em><code class="sig-name descname">MemCfg_TestMode</code><a class="headerlink" href="#_CPPv415MemCfg_TestMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Values that can be passed to <a class="reference internal" href="#group__memcfg__api_1gc8a82f028926cf8a28710f5ba6b0bc89"><span class="std std-ref">MemCfg_setTestMode()</span></a> as the <em>testMode</em> parameter. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv422MEMCFG_TEST_FUNCTIONAL">
<span id="_CPPv322MEMCFG_TEST_FUNCTIONAL"></span><span id="_CPPv222MEMCFG_TEST_FUNCTIONAL"></span><span class="target" id="group__memcfg__api_1ggcc0bcf96536c11210db605f4f1268eefe623f7bd3bf338fcb7612bb97832b436"></span><code class="sig-name descname">MEMCFG_TEST_FUNCTIONAL</code> = 0<a class="headerlink" href="#_CPPv422MEMCFG_TEST_FUNCTIONAL" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Functional mode. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv422MEMCFG_TEST_WRITE_DATA">
<span id="_CPPv322MEMCFG_TEST_WRITE_DATA"></span><span id="_CPPv222MEMCFG_TEST_WRITE_DATA"></span><span class="target" id="group__memcfg__api_1ggcc0bcf96536c11210db605f4f1268eef11802d30f9367c1c63ad2a477a91a262"></span><code class="sig-name descname">MEMCFG_TEST_WRITE_DATA</code> = 1<a class="headerlink" href="#_CPPv422MEMCFG_TEST_WRITE_DATA" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes allowed to data only. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv421MEMCFG_TEST_WRITE_ECC">
<span id="_CPPv321MEMCFG_TEST_WRITE_ECC"></span><span id="_CPPv221MEMCFG_TEST_WRITE_ECC"></span><span class="target" id="group__memcfg__api_1ggcc0bcf96536c11210db605f4f1268eef5d75e5b5dda2c958a606c6561b9dc14e"></span><code class="sig-name descname">MEMCFG_TEST_WRITE_ECC</code> = 2<a class="headerlink" href="#_CPPv421MEMCFG_TEST_WRITE_ECC" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes allowed to ECC only (for DxRAM). </p>
</dd></dl>

<dl class="cpp enumerator">
<dt id="_CPPv424MEMCFG_TEST_WRITE_PARITY">
<span id="_CPPv324MEMCFG_TEST_WRITE_PARITY"></span><span id="_CPPv224MEMCFG_TEST_WRITE_PARITY"></span><span class="target" id="group__memcfg__api_1ggcc0bcf96536c11210db605f4f1268eefb26f23fb5e7a12eb2cae3fda6a9ec751"></span><code class="sig-name descname">MEMCFG_TEST_WRITE_PARITY</code> = 2<a class="headerlink" href="#_CPPv424MEMCFG_TEST_WRITE_PARITY" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Writes allowed to parity only (for LSxRAM, GSxRAM, and MSGxRAM). </p>
</dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="cpp function">
<dt id="_CPPv420MemCfg_setCLAMemType8uint32_t20MemCfg_CLAMemoryType">
<span id="_CPPv320MemCfg_setCLAMemType8uint32_t20MemCfg_CLAMemoryType"></span><span id="_CPPv220MemCfg_setCLAMemType8uint32_t20MemCfg_CLAMemoryType"></span><span id="MemCfg_setCLAMemType__uint32_t.MemCfg_CLAMemoryType"></span><span class="target" id="group__memcfg__api_1g3196086df04b57ef67f5f6c425287274"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_setCLAMemType</code><span class="sig-paren">(</span>uint32_t <em>ramSections</em>, <a class="reference internal" href="#_CPPv420MemCfg_CLAMemoryType" title="MemCfg_CLAMemoryType">MemCfg_CLAMemoryType</a> <em>claMemType</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420MemCfg_setCLAMemType8uint32_t20MemCfg_CLAMemoryType" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the CLA memory type of the specified RAM section.</p>
<p><p>This function sets the CLA memory type configuration of the RAM section. If the </p>
<em>claMemType</em> parameter is <strong>MEMCFG_CLA_MEM_DATA</strong>, the RAM section will be configured as CLA data memory. If <strong>MEMCFG_CLA_MEM_PROGRAM</strong>, the RAM section will be configured as CLA program memory.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ramSections</span></code>: is the logical OR of the sections to be configured. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">claMemType</span></code>: indicates data memory or program memory.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>ramSections</em> parameter is an OR of the following indicators: <strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This API only applies to LSx RAM and has no effect if the CLA isn’t master of the memory section.</p>
</dd>
<dt><strong>See</strong></dt><dd><p><a class="reference internal" href="#group__memcfg__api_1gc0296e36c63153eb8b24d19fc7b55a27"><span class="std std-ref">MemCfg_setLSRAMMasterSel()</span></a></p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv431MemCfg_enableViolationInterrupt8uint32_t">
<span id="_CPPv331MemCfg_enableViolationInterrupt8uint32_t"></span><span id="_CPPv231MemCfg_enableViolationInterrupt8uint32_t"></span><span id="MemCfg_enableViolationInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1gd82b1a649077e6c7922703e0193ee570"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_enableViolationInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431MemCfg_enableViolationInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables individual RAM access violation interrupt sources.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be enabled. Can be a logical OR any of the following values:<ul>
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> - Non-master CPU read access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> - Non-master CPU write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> - Non-master CPU fetch access</p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> - Non-master DMA write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> - Non-master CLA1 read access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> - Non-master CLA1 write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> - Non-master CLA1 fetch access</p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> - Master CPU fetch access</p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> - Master CPU write access</p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> - Master DMA write access This function enables the indicated RAM access violation interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv432MemCfg_disableViolationInterrupt8uint32_t">
<span id="_CPPv332MemCfg_disableViolationInterrupt8uint32_t"></span><span id="_CPPv232MemCfg_disableViolationInterrupt8uint32_t"></span><span id="MemCfg_disableViolationInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1g8ede1c8f3c2070dd0f97850b4dfe0553"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_disableViolationInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432MemCfg_disableViolationInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables individual RAM access violation interrupt sources.</p>
<p><p>This function disables the indicated RAM access violation interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be disabled. Can be a logical OR any of the following values:<ul>
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Note that only non-master violations may generate interrupts.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv434MemCfg_getViolationInterruptStatusv">
<span id="_CPPv334MemCfg_getViolationInterruptStatusv"></span><span id="_CPPv234MemCfg_getViolationInterruptStatusv"></span><span id="MemCfg_getViolationInterruptStatus__void"></span><span class="target" id="group__memcfg__api_1g6050d13a162c50ee773af734ae55bc56"></span><em class="property">static</em> uint32_t <code class="sig-name descname">MemCfg_getViolationInterruptStatus</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434MemCfg_getViolationInterruptStatusv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets the current RAM access violation status.</p>
<p>This function returns the RAM access violation status. This function will return flags for both master and non-master access violations although only the non-master flags have the ability to cause the generation of an interrupt.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the current violation status, enumerated as a bit field of the values:<ul class="simple">
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> - Non-master CPU read access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> - Non-master CPU write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> - Non-master CPU fetch access</p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> - Non-master DMA write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> - Non-master CLA1 read access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> - Non-master CLA1 write access</p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> - Non-master CLA1 fetch access</p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> - Master CPU fetch access</p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> - Master CPU write access</p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> - Master DMA write access </p></li>
</ul>
</p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv430MemCfg_forceViolationInterrupt8uint32_t">
<span id="_CPPv330MemCfg_forceViolationInterrupt8uint32_t"></span><span id="_CPPv230MemCfg_forceViolationInterrupt8uint32_t"></span><span id="MemCfg_forceViolationInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1gac573c2bfa8571b5ea70c4e0b75b4c2f"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_forceViolationInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430MemCfg_forceViolationInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the RAM access violation status.</p>
<p><p>This function sets the RAM access violation status. This function will set flags for both master and non-master access violations, and an interrupt will be generated if it is enabled.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the access violation flags to be set. Can be a logical OR any of the following values:<ul>
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv436MemCfg_clearViolationInterruptStatus8uint32_t">
<span id="_CPPv336MemCfg_clearViolationInterruptStatus8uint32_t"></span><span id="_CPPv236MemCfg_clearViolationInterruptStatus8uint32_t"></span><span id="MemCfg_clearViolationInterruptStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1g1e8204f5811edfab40302ff9f14da73c"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_clearViolationInterruptStatus</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436MemCfg_clearViolationInterruptStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears RAM access violation flags.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the access violation flags to be cleared. Can be a logical OR any of the following values:<ul>
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv428MemCfg_setCorrErrorThreshold8uint32_t">
<span id="_CPPv328MemCfg_setCorrErrorThreshold8uint32_t"></span><span id="_CPPv228MemCfg_setCorrErrorThreshold8uint32_t"></span><span id="MemCfg_setCorrErrorThreshold__uint32_t"></span><span class="target" id="group__memcfg__api_1ge8306080a86c5fdebafe24aed0c64332"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_setCorrErrorThreshold</code><span class="sig-paren">(</span>uint32_t <em>threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428MemCfg_setCorrErrorThreshold8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the correctable error threshold value.</p>
<p><p>This value sets the error-count threshold at which a correctable error interrupt is generated. That is when the error count register reaches the value specified by the </p>
<em>threshold</em> parameter, an interrupt is generated if it is enabled.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">threshold</span></code>: is the correctable error threshold.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv424MemCfg_getCorrErrorCountv">
<span id="_CPPv324MemCfg_getCorrErrorCountv"></span><span id="_CPPv224MemCfg_getCorrErrorCountv"></span><span id="MemCfg_getCorrErrorCount__void"></span><span class="target" id="group__memcfg__api_1g781752014e80adb1b963356c0742fa9b"></span><em class="property">static</em> uint32_t <code class="sig-name descname">MemCfg_getCorrErrorCount</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424MemCfg_getCorrErrorCountv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets the correctable error count.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the number of correctable error have occurred. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv431MemCfg_enableCorrErrorInterrupt8uint32_t">
<span id="_CPPv331MemCfg_enableCorrErrorInterrupt8uint32_t"></span><span id="_CPPv231MemCfg_enableCorrErrorInterrupt8uint32_t"></span><span id="MemCfg_enableCorrErrorInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1g243de5f89ef3a36a17b127c66cb7d089"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_enableCorrErrorInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv431MemCfg_enableCorrErrorInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables individual RAM correctable error interrupt sources.</p>
<p><p>This function enables the indicated RAM correctable error interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be enabled. Can take the value <strong>MEMCFG_CERR_CPUREAD</strong> only. Other values are reserved.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Note that only correctable errors may generate interrupts.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv432MemCfg_disableCorrErrorInterrupt8uint32_t">
<span id="_CPPv332MemCfg_disableCorrErrorInterrupt8uint32_t"></span><span id="_CPPv232MemCfg_disableCorrErrorInterrupt8uint32_t"></span><span id="MemCfg_disableCorrErrorInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1g26a62710409fdc4a3ba377f6efb90d80"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_disableCorrErrorInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv432MemCfg_disableCorrErrorInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables individual RAM correctable error interrupt sources.</p>
<p><p>This function disables the indicated RAM correctable error interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be disabled. Can take the value <strong>MEMCFG_CERR_CPUREAD</strong> only. Other values are reserved.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Note that only correctable errors may generate interrupts.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv434MemCfg_getCorrErrorInterruptStatusv">
<span id="_CPPv334MemCfg_getCorrErrorInterruptStatusv"></span><span id="_CPPv234MemCfg_getCorrErrorInterruptStatusv"></span><span id="MemCfg_getCorrErrorInterruptStatus__void"></span><span class="target" id="group__memcfg__api_1ga9b66d97f63a90d068308c8892815706"></span><em class="property">static</em> uint32_t <code class="sig-name descname">MemCfg_getCorrErrorInterruptStatus</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv434MemCfg_getCorrErrorInterruptStatusv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets the current RAM correctable error interrupt status.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the current error interrupt status. Will return a value of <strong>MEMCFG_CERR_CPUREAD</strong> if an interrupt has been generated. If not, the function will return 0. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv430MemCfg_forceCorrErrorInterrupt8uint32_t">
<span id="_CPPv330MemCfg_forceCorrErrorInterrupt8uint32_t"></span><span id="_CPPv230MemCfg_forceCorrErrorInterrupt8uint32_t"></span><span id="MemCfg_forceCorrErrorInterrupt__uint32_t"></span><span class="target" id="group__memcfg__api_1gea0010f3426660170a150d45a527a5c1"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_forceCorrErrorInterrupt</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv430MemCfg_forceCorrErrorInterrupt8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the RAM correctable error interrupt status.</p>
<p><p>This function sets the correctable error interrupt flag.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be set. Can take the value <strong>MEMCFG_CERR_CPUREAD</strong> only. Other values are reserved.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Note that only correctable errors may generate interrupts.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv436MemCfg_clearCorrErrorInterruptStatus8uint32_t">
<span id="_CPPv336MemCfg_clearCorrErrorInterruptStatus8uint32_t"></span><span id="_CPPv236MemCfg_clearCorrErrorInterruptStatus8uint32_t"></span><span id="MemCfg_clearCorrErrorInterruptStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1ge3e2aea0f0f1eb3859c4f7332fb08758"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_clearCorrErrorInterruptStatus</code><span class="sig-paren">(</span>uint32_t <em>intFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv436MemCfg_clearCorrErrorInterruptStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears the RAM correctable error interrupt status.</p>
<p><p>This function clears the correctable error interrupt flag.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlags</span></code>: is a bit mask of the interrupt sources to be cleared. Can take the value <strong>MEMCFG_CERR_CPUREAD</strong> only. Other values are reserved.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Note that only correctable errors may generate interrupts.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv425MemCfg_getCorrErrorStatusv">
<span id="_CPPv325MemCfg_getCorrErrorStatusv"></span><span id="_CPPv225MemCfg_getCorrErrorStatusv"></span><span id="MemCfg_getCorrErrorStatus__void"></span><span class="target" id="group__memcfg__api_1g930f978e34aff769ac1a0f6f8f3318f4"></span><em class="property">static</em> uint32_t <code class="sig-name descname">MemCfg_getCorrErrorStatus</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425MemCfg_getCorrErrorStatusv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets the current correctable RAM error status.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the current error status, enumerated as a bit field of <strong>MEMCFG_CERR_CPUREAD</strong>, <strong>MEMCFG_CERR_DMAREAD</strong>, or <strong>MEMCFG_CERR_CLA1READ</strong> </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv427MemCfg_getUncorrErrorStatusv">
<span id="_CPPv327MemCfg_getUncorrErrorStatusv"></span><span id="_CPPv227MemCfg_getUncorrErrorStatusv"></span><span id="MemCfg_getUncorrErrorStatus__void"></span><span class="target" id="group__memcfg__api_1g134e3c189cde528d8907f7dab4e17c75"></span><em class="property">static</em> uint32_t <code class="sig-name descname">MemCfg_getUncorrErrorStatus</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427MemCfg_getUncorrErrorStatusv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gets the current uncorrectable RAM error status.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the current error status, enumerated as a bit field of <strong>MEMCFG_UCERR_CPUREAD</strong>, <strong>MEMCFG_UCERR_DMAREAD</strong>, <strong>MEMCFG_UCERR_CLA1READ</strong>, or <strong>MEMCFG_UCERR_ECATMEMREAD</strong>. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv427MemCfg_forceCorrErrorStatus8uint32_t">
<span id="_CPPv327MemCfg_forceCorrErrorStatus8uint32_t"></span><span id="_CPPv227MemCfg_forceCorrErrorStatus8uint32_t"></span><span id="MemCfg_forceCorrErrorStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1ge6ab4c9279ca7226c6e89036413abafc"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_forceCorrErrorStatus</code><span class="sig-paren">(</span>uint32_t <em>stsFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427MemCfg_forceCorrErrorStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the specified correctable RAM error status flag.</p>
<p><p>This function sets the specified correctable RAM error status flag.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlags</span></code>: is a bit mask of the error sources. This parameter can be any of the following values: <strong>MEMCFG_CERR_CPUREAD</strong>, <strong>MEMCFG_CERR_DMAREAD</strong>, or <strong>MEMCFG_CERR_CLA1READ</strong>.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv429MemCfg_forceUncorrErrorStatus8uint32_t">
<span id="_CPPv329MemCfg_forceUncorrErrorStatus8uint32_t"></span><span id="_CPPv229MemCfg_forceUncorrErrorStatus8uint32_t"></span><span id="MemCfg_forceUncorrErrorStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1gac869850f5ff6c090b0f937d3634d7ed"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_forceUncorrErrorStatus</code><span class="sig-paren">(</span>uint32_t <em>stsFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429MemCfg_forceUncorrErrorStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the specified uncorrectable RAM error status flag.</p>
<p><p>This function sets the specified uncorrectable RAM error status flag.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlags</span></code>: is a bit mask of the error sources. This parameter can be any of the following values: <strong>MEMCFG_UCERR_CPUREAD</strong>, <strong>MEMCFG_UCERR_DMAREAD</strong>, <strong>MEMCFG_UCERR_CLA1READ</strong>, or <strong>MEMCFG_UCERR_ECATMEMREAD</strong>.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv427MemCfg_clearCorrErrorStatus8uint32_t">
<span id="_CPPv327MemCfg_clearCorrErrorStatus8uint32_t"></span><span id="_CPPv227MemCfg_clearCorrErrorStatus8uint32_t"></span><span id="MemCfg_clearCorrErrorStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1gbf9af338403b090a7dcd5f8910ff6d98"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_clearCorrErrorStatus</code><span class="sig-paren">(</span>uint32_t <em>stsFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv427MemCfg_clearCorrErrorStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears correctable RAM error flags.</p>
<p><p>This function clears the specified correctable RAM error flags.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlags</span></code>: is a bit mask of the status flags to be cleared. This parameter can be any of the <strong>MEMCFG_CERR_CPUREAD</strong>, <strong>MEMCFG_CERR_DMAREAD</strong>, or <strong>MEMCFG_CERR_CLA1READ</strong> values.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv429MemCfg_clearUncorrErrorStatus8uint32_t">
<span id="_CPPv329MemCfg_clearUncorrErrorStatus8uint32_t"></span><span id="_CPPv229MemCfg_clearUncorrErrorStatus8uint32_t"></span><span id="MemCfg_clearUncorrErrorStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1g459a64d51a18191497d667231e3f693d"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_clearUncorrErrorStatus</code><span class="sig-paren">(</span>uint32_t <em>stsFlags</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv429MemCfg_clearUncorrErrorStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clears uncorrectable RAM error flags.</p>
<p><p>This function clears the specified uncorrectable RAM error flags.</p>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlags</span></code>: is a bit mask of the status flags to be cleared. This parameter can be any of the <strong>MEMCFG_UCERR_CPUREAD</strong>, <strong>MEMCFG_UCERR_DMAREAD</strong>, <strong>MEMCFG_UCERR_CLA1READ</strong>, or <strong>MEMCFG_UCERR_ECATMEMREAD</strong> values.</p></li>
</ul>
</dd>
</dl>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv425MemCfg_enableROMWaitStatev">
<span id="_CPPv325MemCfg_enableROMWaitStatev"></span><span id="_CPPv225MemCfg_enableROMWaitStatev"></span><span id="MemCfg_enableROMWaitState__void"></span><span class="target" id="group__memcfg__api_1g7bd53c5285d34efb725a65d10712e1a2"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_enableROMWaitState</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425MemCfg_enableROMWaitStatev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables ROM wait state.</p>
<p>This function enables the ROM wait state. This mean CPU accesses to ROM are 1-wait.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv426MemCfg_disableROMWaitStatev">
<span id="_CPPv326MemCfg_disableROMWaitStatev"></span><span id="_CPPv226MemCfg_disableROMWaitStatev"></span><span id="MemCfg_disableROMWaitState__void"></span><span class="target" id="group__memcfg__api_1gfdfae48e2ca65ac6614eb291b828cb11"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_disableROMWaitState</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426MemCfg_disableROMWaitStatev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables ROM wait state.</p>
<p>This function enables the ROM wait state. This mean CPU accesses to ROM are 0-wait.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv424MemCfg_enableROMPrefetchv">
<span id="_CPPv324MemCfg_enableROMPrefetchv"></span><span id="_CPPv224MemCfg_enableROMPrefetchv"></span><span id="MemCfg_enableROMPrefetch__void"></span><span class="target" id="group__memcfg__api_1g59bf20bc87459bbb97509eed19844b8f"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_enableROMPrefetch</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424MemCfg_enableROMPrefetchv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Enables ROM prefetch.</p>
<p>This function enables the ROM prefetch for both secure ROM and boot ROM.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv425MemCfg_disableROMPrefetchv">
<span id="_CPPv325MemCfg_disableROMPrefetchv"></span><span id="_CPPv225MemCfg_disableROMPrefetchv"></span><span id="MemCfg_disableROMPrefetch__void"></span><span class="target" id="group__memcfg__api_1g5d9c01010b79078a179c06aceabee0c5"></span><em class="property">static</em> void <code class="sig-name descname">MemCfg_disableROMPrefetch</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv425MemCfg_disableROMPrefetchv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disables ROM prefetch.</p>
<p>This function enables the ROM prefetch for both secure ROM and boot ROM.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv417MemCfg_lockConfig8uint32_t">
<span id="_CPPv317MemCfg_lockConfig8uint32_t"></span><span id="_CPPv217MemCfg_lockConfig8uint32_t"></span><span id="MemCfg_lockConfig__uint32_t"></span><span class="target" id="group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"></span>void <code class="sig-name descname">MemCfg_lockConfig</code><span class="sig-paren">(</span>uint32_t <em>memSections</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417MemCfg_lockConfig8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Locks the writes to the configuration of specified memory sections.</p>
<p><p>This function locks writes to the access protection and master select configuration of a memory section.That means calling </p>
<a class="reference internal" href="#group__memcfg__api_1ga7ec2410615ad7a8a9d244c6cb068880"><span class="std std-ref">MemCfg_setProtection()</span></a> or <a class="reference internal" href="#group__memcfg__api_1gc0296e36c63153eb8b24d19fc7b55a27"><span class="std std-ref">MemCfg_setLSRAMMasterSel()</span></a> for a locked memory section will have no effect until <a class="reference internal" href="#group__memcfg__api_1g10ed027c8b9529409e88daeda540e7d9"><span class="std std-ref">MemCfg_unlockConfig()</span></a> is called.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memSections</span></code>: is the logical OR of the sections to be configured.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>memSections</em> parameter is an OR of one of the following sets of indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_D0</strong> and <strong>MEMCFG_SECT_D1</strong> or <strong>MEMCFG_SECT_DX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> or <strong>MEMCFG_SECT_LSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> or <strong>MEMCFG_SECT_GSX_ALL</strong> </p></li>
<li><p><strong>OR</strong> use <strong>MEMCFG_SECT_ALL</strong> to configure all possible sections.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv419MemCfg_unlockConfig8uint32_t">
<span id="_CPPv319MemCfg_unlockConfig8uint32_t"></span><span id="_CPPv219MemCfg_unlockConfig8uint32_t"></span><span id="MemCfg_unlockConfig__uint32_t"></span><span class="target" id="group__memcfg__api_1g10ed027c8b9529409e88daeda540e7d9"></span>void <code class="sig-name descname">MemCfg_unlockConfig</code><span class="sig-paren">(</span>uint32_t <em>memSections</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419MemCfg_unlockConfig8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unlocks the writes to the configuration of a memory section.</p>
<p><p>This function unlocks writes to the access protection and master select configuration of a memory section that has been locked using </p>
<a class="reference internal" href="#group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"><span class="std std-ref">MemCfg_lockConfig()</span></a>.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memSections</span></code>: is the logical OR of the sections to be configured.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>memSections</em> parameter is an OR of one of the following sets of indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_D0</strong> and <strong>MEMCFG_SECT_D1</strong> or <strong>MEMCFG_SECT_DX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> or <strong>MEMCFG_SECT_LSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> or <strong>MEMCFG_SECT_GSX_ALL</strong> </p></li>
<li><p><strong>OR</strong> use <strong>MEMCFG_SECT_ALL</strong> to configure all possible sections.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv419MemCfg_commitConfig8uint32_t">
<span id="_CPPv319MemCfg_commitConfig8uint32_t"></span><span id="_CPPv219MemCfg_commitConfig8uint32_t"></span><span id="MemCfg_commitConfig__uint32_t"></span><span class="target" id="group__memcfg__api_1g47ea721f185c652e77d4600427c608a0"></span>void <code class="sig-name descname">MemCfg_commitConfig</code><span class="sig-paren">(</span>uint32_t <em>memSections</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419MemCfg_commitConfig8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Permanently locks writes to the configuration of a memory section.</p>
<p><p>This function permanently locks writes to the access protection and master select configuration of a memory section. That means calling </p>
<a class="reference internal" href="#group__memcfg__api_1ga7ec2410615ad7a8a9d244c6cb068880"><span class="std std-ref">MemCfg_setProtection()</span></a> or <a class="reference internal" href="#group__memcfg__api_1gc0296e36c63153eb8b24d19fc7b55a27"><span class="std std-ref">MemCfg_setLSRAMMasterSel()</span></a> for a locked memory section will have no effect. To lock the configuration in a nonpermanent way, use <a class="reference internal" href="#group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"><span class="std std-ref">MemCfg_lockConfig()</span></a>.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memSections</span></code>: is the logical OR of the sections to be configured.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>memSections</em> parameter is an OR of one of the following sets of indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_D0</strong> and <strong>MEMCFG_SECT_D1</strong> or <strong>MEMCFG_SECT_DX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> or <strong>MEMCFG_SECT_LSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> or <strong>MEMCFG_SECT_GSX_ALL</strong> </p></li>
<li><p><strong>OR</strong> use <strong>MEMCFG_SECT_ALL</strong> to configure all possible sections.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv420MemCfg_setProtection8uint32_t8uint32_t">
<span id="_CPPv320MemCfg_setProtection8uint32_t8uint32_t"></span><span id="_CPPv220MemCfg_setProtection8uint32_t8uint32_t"></span><span id="MemCfg_setProtection__uint32_t.uint32_t"></span><span class="target" id="group__memcfg__api_1ga7ec2410615ad7a8a9d244c6cb068880"></span>void <code class="sig-name descname">MemCfg_setProtection</code><span class="sig-paren">(</span>uint32_t <em>memSection</em>, uint32_t <em>protectMode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420MemCfg_setProtection8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the access protection mode of a single memory section.</p>
<p><p>This function sets the access protection mode of a specified memory section. The mode is passed into the </p>
<em>protectMode</em> parameter as the logical OR of the following values:<ul class="simple">
<li><p><strong>MEMCFG_PROT_ALLOWCPUFETCH</strong> or <strong>MEMCFG_PROT_BLOCKCPUFETCH</strong> - CPU fetch</p></li>
<li><p><strong>MEMCFG_PROT_ALLOWCPUWRITE</strong> or <strong>MEMCFG_PROT_BLOCKCPUWRITE</strong> - CPU write</p></li>
<li><p><strong>MEMCFG_PROT_ALLOWDMAWRITE</strong> or <strong>MEMCFG_PROT_BLOCKDMAWRITE</strong> - DMA write</p></li>
</ul>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memSection</span></code>: is the memory section to be configured. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">protectMode</span></code>: is the logical OR of the settings to be applied.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>memSection</em> parameter is one of the following indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_D0</strong> or <strong>MEMCFG_SECT_D1</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> </p></li>
</ul>
</p>
<p>This function will have no effect if the associated registers have been locked by <a class="reference internal" href="#group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"><span class="std std-ref">MemCfg_lockConfig()</span></a> or <a class="reference internal" href="#group__memcfg__api_1g47ea721f185c652e77d4600427c608a0"><span class="std std-ref">MemCfg_commitConfig()</span></a> or if the memory is configured as CLA program memory.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv424MemCfg_setLSRAMMasterSel8uint32_t21MemCfg_LSRAMMasterSel">
<span id="_CPPv324MemCfg_setLSRAMMasterSel8uint32_t21MemCfg_LSRAMMasterSel"></span><span id="_CPPv224MemCfg_setLSRAMMasterSel8uint32_t21MemCfg_LSRAMMasterSel"></span><span id="MemCfg_setLSRAMMasterSel__uint32_t.MemCfg_LSRAMMasterSel"></span><span class="target" id="group__memcfg__api_1gc0296e36c63153eb8b24d19fc7b55a27"></span>void <code class="sig-name descname">MemCfg_setLSRAMMasterSel</code><span class="sig-paren">(</span>uint32_t <em>ramSection</em>, <a class="reference internal" href="#_CPPv421MemCfg_LSRAMMasterSel" title="MemCfg_LSRAMMasterSel">MemCfg_LSRAMMasterSel</a> <em>masterSel</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424MemCfg_setLSRAMMasterSel8uint32_t21MemCfg_LSRAMMasterSel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the master of the specified LSxRAM section.</p>
<p><p>This function sets the master select configuration of the LSxRAM section.If the </p>
<em>masterSel</em> parameter is <strong>MEMCFG_LSRAMMASTER_CPU_ONLY</strong>, the LSxRAM section passed into the <em>ramSection</em> parameter will be dedicated to the CPU. If <strong>MEMCFG_LSRAMMASTER_CPU_CLA1</strong>, the memory section will be shared between the CPU and the CLA.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ramSection</span></code>: is the LSxRAM section to be configured. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">masterSel</span></code>: is the sharing selection.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>ramSection</em> parameter should be a value from <strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong>.</p>
<p>This function will have no effect if the associated registers have been locked by <a class="reference internal" href="#group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"><span class="std std-ref">MemCfg_lockConfig()</span></a> or <a class="reference internal" href="#group__memcfg__api_1g47ea721f185c652e77d4600427c608a0"><span class="std std-ref">MemCfg_commitConfig()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This API only applies to LSxRAM.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv424MemCfg_setGSRAMMasterSel8uint32_t21MemCfg_GSRAMMasterSel">
<span id="_CPPv324MemCfg_setGSRAMMasterSel8uint32_t21MemCfg_GSRAMMasterSel"></span><span id="_CPPv224MemCfg_setGSRAMMasterSel8uint32_t21MemCfg_GSRAMMasterSel"></span><span id="MemCfg_setGSRAMMasterSel__uint32_t.MemCfg_GSRAMMasterSel"></span><span class="target" id="group__memcfg__api_1gbf7d1f375842e688acc5fabf7e2c655b"></span>void <code class="sig-name descname">MemCfg_setGSRAMMasterSel</code><span class="sig-paren">(</span>uint32_t <em>ramSections</em>, <a class="reference internal" href="#_CPPv421MemCfg_GSRAMMasterSel" title="MemCfg_GSRAMMasterSel">MemCfg_GSRAMMasterSel</a> <em>masterSel</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424MemCfg_setGSRAMMasterSel8uint32_t21MemCfg_GSRAMMasterSel" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the master of the specified GSxRAM section.</p>
<p><p>This function sets the master select configuration of the GSxRAM section.If the </p>
<em>masterSel</em> parameter is <strong>MEMCFG_GSRAMMASTER_CPU1</strong>, the GSRAM sections passed into the <em>ramSections</em> parameter will be dedicated to CPU1. If <strong>MEMCFG_GSRAMMASTER_CPU2</strong>, the memory section will be dedicated to CPU2.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ramSections</span></code>: is the logical OR of the sections to be configured. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">masterSel</span></code>: is the sharing selection.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>ramSections</em> parameter should be a logical OR of values from <strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong>.</p>
<p>This function will have no effect if the associated registers have been locked by <a class="reference internal" href="#group__memcfg__api_1g87a3905e9b73981a95f7c39d5ad2c2ed"><span class="std std-ref">MemCfg_lockConfig()</span></a> or <a class="reference internal" href="#group__memcfg__api_1g47ea721f185c652e77d4600427c608a0"><span class="std std-ref">MemCfg_commitConfig()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>This API only applies to GSxRAM.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv418MemCfg_setTestMode8uint32_t15MemCfg_TestMode">
<span id="_CPPv318MemCfg_setTestMode8uint32_t15MemCfg_TestMode"></span><span id="_CPPv218MemCfg_setTestMode8uint32_t15MemCfg_TestMode"></span><span id="MemCfg_setTestMode__uint32_t.MemCfg_TestMode"></span><span class="target" id="group__memcfg__api_1gc8a82f028926cf8a28710f5ba6b0bc89"></span>void <code class="sig-name descname">MemCfg_setTestMode</code><span class="sig-paren">(</span>uint32_t <em>memSection</em>, <a class="reference internal" href="#_CPPv415MemCfg_TestMode" title="MemCfg_TestMode">MemCfg_TestMode</a> <em>testMode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418MemCfg_setTestMode8uint32_t15MemCfg_TestMode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sets the test mode of the specified memory section.</p>
<p><p>This function sets the test mode configuration of the RAM section. The </p>
<em>testMode</em> parameter can take one of the following values:<ul class="simple">
<li><p><strong>MEMCFG_TEST_FUNCTIONAL</strong> </p></li>
<li><p><strong>MEMCFG_TEST_WRITE_DATA</strong> </p></li>
<li><p><strong>MEMCFG_TEST_WRITE_ECC</strong> (DxRAM) or MEMCFG_TEST_WRITE_PARITY (LSx, GSx, or MSGxRAM)</p></li>
</ul>
<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memSection</span></code>: is the memory section to be configured. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">testMode</span></code>: is the test mode selected.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>memSection</em> parameter is one of the following indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_M0</strong> or <strong>MEMCFG_SECT_M1</strong> </p></li>
<li><p><strong>MEMCFG_SECT_D0</strong> or <strong>MEMCFG_SECT_D1</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> </p></li>
<li><p><strong>MEMCFG_SECT_MSGCPUTOCPU</strong>, <strong>MEMCFG_SECT_MSGCPUTOCLA1</strong>, or <strong>MEMCFG_SECT_MSGCLA1TOCPU</strong> </p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv419MemCfg_initSections8uint32_t">
<span id="_CPPv319MemCfg_initSections8uint32_t"></span><span id="_CPPv219MemCfg_initSections8uint32_t"></span><span id="MemCfg_initSections__uint32_t"></span><span class="target" id="group__memcfg__api_1g294f3d574d7a4ffedd6e7b0b68fb149b"></span>void <code class="sig-name descname">MemCfg_initSections</code><span class="sig-paren">(</span>uint32_t <em>ramSections</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419MemCfg_initSections8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Starts the initialization the specified RAM sections.</p>
<p><p>This function starts the initialization of the specified RAM sections. Use </p>
<a class="reference internal" href="#group__memcfg__api_1g7e12ccf8100a291e30af86eb38272f80"><span class="std std-ref">MemCfg_getInitStatus()</span></a> to check if the initialization is done.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ramSections</span></code>: is the logical OR of the sections to be initialized.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>ramSections</em> parameter is an OR of one of the following sets of indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_M0</strong>, <strong>MEMCFG_SECT_M1</strong>, <strong>MEMCFG_SECT_D0</strong>, and <strong>MEMCFG_SECT_D1</strong> or <strong>MEMCFG_SECT_DX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> or <strong>MEMCFG_SECT_LSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> or <strong>MEMCFG_SECT_GSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_MSGCPUTOCPU</strong>, <strong>MEMCFG_SECT_MSGCPUTOCLA1</strong>, and <strong>MEMCFG_SECT_MSGCLA1TOCPU</strong> or <strong>MEMCFG_SECT_MSGX_ALL</strong> </p></li>
<li><p><strong>OR</strong> use <strong>MEMCFG_SECT_ALL</strong> to configure all possible sections.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>None. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv420MemCfg_getInitStatus8uint32_t">
<span id="_CPPv320MemCfg_getInitStatus8uint32_t"></span><span id="_CPPv220MemCfg_getInitStatus8uint32_t"></span><span id="MemCfg_getInitStatus__uint32_t"></span><span class="target" id="group__memcfg__api_1g7e12ccf8100a291e30af86eb38272f80"></span>bool <code class="sig-name descname">MemCfg_getInitStatus</code><span class="sig-paren">(</span>uint32_t <em>ramSections</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420MemCfg_getInitStatus8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the status of initialized RAM sections.</p>
<p><p>This function gets the initialization status of the RAM sections specified by the </p>
<em>ramSections</em> parameter.<dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ramSections</span></code>: is the logical OR of the sections to be checked.</p></li>
</ul>
</dd>
</dl>
</p>
<p>The <em>ramSections</em> parameter is an OR of one of the following sets of indicators:<ul class="simple">
<li><p><strong>MEMCFG_SECT_M0</strong>, <strong>MEMCFG_SECT_M1</strong>, <strong>MEMCFG_SECT_D0</strong>, and <strong>MEMCFG_SECT_D1</strong> or <strong>MEMCFG_SECT_DX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_LS0</strong> through <strong>MEMCFG_SECT_LSx</strong> or <strong>MEMCFG_SECT_LSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_GS0</strong> through <strong>MEMCFG_SECT_GSx</strong> or <strong>MEMCFG_SECT_GSX_ALL</strong> </p></li>
<li><p><strong>MEMCFG_SECT_MSGCPUTOCPU</strong>, <strong>MEMCFG_SECT_MSGCPUTOCLA1</strong>, and <strong>MEMCFG_SECT_MSGCLA1TOCPU</strong> or <strong>MEMCFG_SECT_MSGX_ALL</strong> </p></li>
<li><p><strong>OR</strong> use <strong>MEMCFG_SECT_ALL</strong> to get status of all possible sections.</p></li>
</ul>
</p>
<p><dl class="simple">
<dt><strong>Note</strong></dt><dd><p>Use <a class="reference internal" href="#group__memcfg__api_1g294f3d574d7a4ffedd6e7b0b68fb149b"><span class="std std-ref">MemCfg_initSections()</span></a> to start the initialization.</p>
</dd>
<dt><strong>Return</strong></dt><dd><p>Returns <strong>true</strong> if all the sections specified by <em>ramSections</em> have been initialized and <strong>false</strong> if not. </p>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv426MemCfg_getViolationAddress8uint32_t">
<span id="_CPPv326MemCfg_getViolationAddress8uint32_t"></span><span id="_CPPv226MemCfg_getViolationAddress8uint32_t"></span><span id="MemCfg_getViolationAddress__uint32_t"></span><span class="target" id="group__memcfg__api_1g23e44a319d1edfb7eec1c62e6755c350"></span>uint32_t <code class="sig-name descname">MemCfg_getViolationAddress</code><span class="sig-paren">(</span>uint32_t <em>intFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426MemCfg_getViolationAddress8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the violation address associated with a intFlag.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the violation address associated with the <em>intFlag</em>. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">intFlag</span></code>: is the type of access violation as indicated by ONE of these values:<ul>
<li><p><strong>MEMCFG_NMVIOL_CPUREAD</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_DMAWRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1READ</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1WRITE</strong> </p></li>
<li><p><strong>MEMCFG_NMVIOL_CLA1FETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUFETCH</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_CPUWRITE</strong> </p></li>
<li><p><strong>MEMCFG_MVIOL_DMAWRITE</strong> </p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv426MemCfg_getCorrErrorAddress8uint32_t">
<span id="_CPPv326MemCfg_getCorrErrorAddress8uint32_t"></span><span id="_CPPv226MemCfg_getCorrErrorAddress8uint32_t"></span><span id="MemCfg_getCorrErrorAddress__uint32_t"></span><span class="target" id="group__memcfg__api_1g025ed800455ab7ab93cab55c2a39b9c8"></span>uint32_t <code class="sig-name descname">MemCfg_getCorrErrorAddress</code><span class="sig-paren">(</span>uint32_t <em>stsFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv426MemCfg_getCorrErrorAddress8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the correctable error address associated with a stsFlag.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the error address associated with the stsFlag. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlag</span></code>: is the type of error to which the returned address will correspond. Can currently take the value <strong>MEMCFG_CERR_CPUREAD</strong> only. Other values are reserved.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv428MemCfg_getUncorrErrorAddress8uint32_t">
<span id="_CPPv328MemCfg_getUncorrErrorAddress8uint32_t"></span><span id="_CPPv228MemCfg_getUncorrErrorAddress8uint32_t"></span><span id="MemCfg_getUncorrErrorAddress__uint32_t"></span><span class="target" id="group__memcfg__api_1g56147e162c824cb5f0c309890c29eab1"></span>uint32_t <code class="sig-name descname">MemCfg_getUncorrErrorAddress</code><span class="sig-paren">(</span>uint32_t <em>stsFlag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv428MemCfg_getUncorrErrorAddress8uint32_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the uncorrectable error address associated with a stsFlag.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the error address associated with the stsFlag. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stsFlag</span></code>: is the type of error to which the returned address will correspond. It may be passed one of these values: <strong>MEMCFG_UCERR_CPUREAD</strong>, <strong>MEMCFG_UCERR_DMAREAD</strong>, <strong>MEMCFG_UCERR_CLA1READ</strong>, or <strong>MEMCFG_UCERR_ECATMEMREAD</strong> values.</p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<p>Many of the functions provided by this API to configure RAM sections’ settings
will take a RAM section identifier or an OR of several identifiers as a
parameter. These are #defines with names in the format  MEMCFG_SECT_X.
Take care to read the function description to learn which functions can operate
on multiple sections of the same type at a time and which ones can only
configure one section at a time. A quick way to check this is to see if the
parameter says e ramSection or the plural e ramSections. Some functions may
also be able to take a  MEMCFG_SECT_ALL value to indicate that all RAM
sections should be operated on at the same time. Again, read the function’s
detailed description to be sure.</p>
<p>The code for this module is contained in driverlib/memcfg.c, with driverlib/memcfg.h containing the API declarations for use by applications.</p>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sci.html" class="btn btn-neutral float-right" title="SCI Module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mcbsp.html" class="btn btn-neutral float-left" title="MCBSP Module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">2020, Texas Instruments Incorporated</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
      <span class="lastupdated">
        Last updated on May 26, 2020.
      </span>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'v3.02.00.00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

    <script type="text/javascript" src="_static/searchtools.js"></script>
    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });

        $('body').on("mousewheel", function () {
            // Remove default behavior
            event.preventDefault();
            // Scroll without smoothing
            var wheelDelta = event.wheelDelta;
            var currentScrollPosition = window.pageYOffset;
            window.scrollTo(0, currentScrollPosition - wheelDelta);
        });
      });
  </script>
   

</body>
</html>